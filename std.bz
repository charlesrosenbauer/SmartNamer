Std $Module










"Signed Integers"
Int :: (I8, I16, I32, I64)
I8  :: $Int8
I16 :: $Int16
I32 :: $Int32
I64 :: $Int64

"Unsigned Integers"
Unt :: (U8, U16, U32, U64)
U8  :: $Unt8
U16 :: $Unt16
U32 :: $Unt32
U64 :: $Unt64

"Floating Point"
Flt :: (F16, F32, F64)
F16 :: $Flt16
F32 :: $Flt32
F64 :: $Flt64

"John Gustafson's Unums, because we need associative floats"
Unm :: (N16, N32, N64)
N16 :: $Unm16
N32 :: $Unm32
N64 :: $Unm64

Num  :: (Int, Unt, Flt, Unm)

Real :: (Flt, Unm)

Discrete :: (Int, Unt)

Bl :: (True, False) $BoolTF


+ :: (N':Num. N') ;; N'
+ :: $add-binop

- :: (N':Num. N') ;; N'
- :: $sub-binop

* :: (N':Num. N') ;; N'
* :: $mul-binop

/ :: (N':Num. N') ;; (N', ())
(x. 0) / :: ()
/ :: $div-binop

% :: (N':Num. N') ;; N'
% :: $mod-binop


>  :: (N':Num. N') ;; Bl
>  :: $gtr-binop

<  :: (N':Num. N') ;; Bl
<  :: $lss-binop

>= :: (N':Num. N') ;; Bl
>= :: $geq-binop

=< :: (N':Num. N') ;; Bl
=< :: $leq-binop

=  :: (N':Num. N') ;; Bl
=  :: $eql-binop

!= :: (N':Num. N') ;; Bl
!= :: $neq-binop

!! :: Bl ;; Bl
(True ) !! :: False
(False) !! :: True

&& :: (Bl. Bl) ;; Bl
(True. True) && :: True
(x.    y   ) && :: False

|| :: (Bl. Bl) ;; Bl
(False. False) || :: False
(x.     y    ) || :: True

? :: (Bl. A. B) ;; (A, B)
(True.  x. _) ? :: x
(False. _. y) ? :: y

!? :: (Bl. A. B) ;; (A, B)
(True.  _. y) !? :: y
(False. x. _) !? :: x

(T') Maybe :: (Just:T', Nothing:())

(A'. B') Either :: (Left:A', Right:B')










+1 :: (N':Num) ;; N'
+1 :: 1`+

-1 :: (N':Num) ;; N'
-1 :: 1`-

+2 :: (N':Num) ;; N'
+2 :: 2`+

-2 :: (N':Num) ;; N'
-2 :: 2`-

*2 :: (N':Num) ;; N'
*2 :: 2`*

/2 :: (N':Num) ;; N'
/2 :: 2`*

*3 :: (N':Num) ;; N'
(x) *3 :: (x. x *2)+

/3 :: (N':Num) ;; N'
/3 :: 3`/

%2 :: (N':Num) ;; N'
%2 :: 2`%

%3 :: (N':Num) ;; N'
%3 :: 3`%

^2 :: (N':Num) ;; N'
(x) ^2 :: (x. x)*

^3 :: (N':Num) ;; N'
(x) ^3 :: (x. x ^2)*
